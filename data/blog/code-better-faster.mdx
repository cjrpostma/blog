---
title: Notes from a lecture on coding better, faster
date: '2022-11-20'
tags: ['career']
draft: true
summary: TODO
---

Today I attended and very much enjoyed a webinar hosted by Rahul Pandey and Alex Chiou of Taro.
Both Rahul and Alex are ex-tech leads from FAANG companies. The title of the webinar is
"How To Write Better Code Faster As A Software Engineer". These are my notes from the webinar.

There are two axes to being a good "code machine".

1. Quality
2. Velocity

"Code Machine", by the way, is a recognized archetype of staff engineers at certain larger tech companies.
Another archetype of a staff engineer might be "Product Manager" for those excelling in that skillset.

A common misconception about delivering lots of software quickly is that you have to sacrifice quality.
High quality code is conducive to high output. This is important at any level of engineering. Alex states
that even the highest level of engineers, despite having more meetings, still spend about 20% of their time
writing code.

Code quality is by far the most misunderstood metric.

- A trademark sign of a bad software engineer is low code quality

You can always throw more hours to increase quantity, you cannot do so for quality.

# Velocity

The following are ideas for how to think about and optimize coding velocity.

### Go deep, not wide

- Pick one tech stack and stick with it
- Breadth is cheap
- Takes 2-4 years to become proficient at a stack
- Avoid being full stack
- Will eventually hit an inflection point where you can code really fast
- Don't switch stacks to maximize job opportunity

### Be tactical with meetings

A common failure mode is to attend every meeting on your calendar.

- Juniors commonly do this
- Skip meetings where you aren't a major player
- Always retrospect on meeting value
- Establish focus blocks, a long period of time that is uninterrupted where you can focus
- Try to have 1-2 days per week with no interruptions/meetings

Coding is heavily momentum oriented. Context switching is really disruptive, takes a long time to get the
context and setup the environment to write code.

An engineer with 1 x 8 hours blocks of time will produce twice as much as code as an engineer with 4 x 2 hour blocks
of time.

### Look for patterns

All tech stacks follow a power law.

- Some components matter far more than others. For example, rendering a list of items on mobile.
- Should have an opinion on these common components. For example, should know that there are three ways.
  to do this, this way is better for this reason, etc. Know pros and cons of all approaches for these common items.
- Identify common components to master (e.g. if frontend).
- Once you have identified these patterns, which may be unique per team/org, get really good at them, at those patterns.
  Learn how to get really good at these common things/patterns

## Do side projects

- "Life hack" to write more code without overworking
- Build things for fun on the side
- This builds skills
- If you want to get better at a skill, just need to spend more time practicing that skill
- This is especially powerful if you work at a startup and work on frontend
- Can almost copy/paste code from your personal side project into work work because you've already solved a lot
  of problems in your side projects.

Other benefits of side projects:

- Fun
- Builds more holistic product skills
- Make you a more complete engineer
- Will help spark creativity at work
- Will help you learn more modern ways to do things because work projects might persist older patterns
- Side project allows you to explore modern approaches

### Time spent after writing code

What is the breakdown of how time is spent once a PR is submitted. For example, what happens once you write
the code to getting it landed (e.g. committed to main).

A novice engineer will:

- Submit code for review and spend little time on adding a summary, test plan, screenshots, etc.
- Will take longer to respond to code review and code review will take longer because PRs are disorganized and
  don't have great summary or test plan. Colleagues are less likely to want to review such PRs. Colleagues have
  less trust in the PR and programmer behind it.
- Land code into main a greater amount of time in the future from when the PR was submitted

A pro engineer will:

- Submit code for review and spend a longer time here, very carefully explaining the PR, adding videos, screenshots,
  notes, and areas of question.
- Code review time is way faster due to step one being more complete
- Land code -- takes less time, will land the code right away, this time should be as fast as possible.

The goal is that you want this cycle to to be super quick. The pro engineer explains very well what they are doing
and anticipates the questions that other people will have in the test plan summary. This allows the PR review
to be expedited.

HOW DO I INSERT AN IMAGE HERE?

# Quality

Create a plan

- try to visualize your approach and come up with a plan
  -- dont jumop right into coding
  --crucial with meatier tasks ( greater than 3 days)
- dont just start coding your first idea, come up with alternative ideas
- jsut spend at least 15-30 minutes to come up with a plan
- come up with pros/cons of approaches

Submit clean pull requests

- code is much mroe than the raw lines of code
-

- Make commit focused/atomic, 25-250 lines of code, otherwise robbing yourself of feed back that yiou need
  explain what PR is trying to accomplish and how
- Proactively surface potential problem areas
  ---- mention on pull request if yiou think there are issues in your PR, be proactive
  ---- can mention code smells or areas you think are messy in your own PR

- Have a great test plan
  -- Show waht the code is trying to do
  -- if on front end, 99% of the time you want to attach video or gif
  if backend, screenshot of postman, curl, etc
- providing more info not oinly shows that your code works but also builds up confidence in yiour code from rest of yoru
  team
- doing the above will also result in faster code review because it is easier to review
- test plan should communicate a narrative, waht changes the code makes
- state of world, made code change, new state of the world....explain this narrative
- prove the change and how it looks/works
- call out the significant lines of code ( the import parts of the changes)

Treat code review feedback as a massive gift

- respond quickly and with appreciation
- ideally within 1-4 hours, 24 hour turnaround max
- code review is one the primary ways you can grow
- dont make the same mistake twice, absorb the feedback, if you dont get it, ask questions
- dont be afraid to hop on a call to explain concepts in PR

Review code from others

- a couple hours per week to review code from other team members even if you cannot approve
- help your teammates
- find areas for improvement that you can make

Modularize your code

-dont put everything into one class

- every component should have a single responsibility
- namign is very important, use descriptive names to make this clear
- more modularization ===increased flexibility === increased reusability

Keep it consistent

- follow what the surrounding code is doing
- even if the existing patterns are suboptimal, just do the same thing, having two patterns, even if one is better
  really makes the code harder to read
  if you are going to bring in a new thing, you need to migrate the whole codebase
  it is better to just have one pattern, even if that one pattern is a little older
- if you are going to improve the code, do a global scale refactor
- you can keep mental notes on thigns to improve
- code following different patterns breaks the readers' focus

Do the simple thing first

- start off with the most basic and minimal frameworks
- by using the more primitive technology, you will understand the tech better
- worst possible code is using powerful framework incorrectly

Make it a little better each time

-pay attention to pain points

-can you do the same with less code

- can you make it more readable
- can you make it faster
- are there unhandled edge cases

note these things and discuss with other people

Where to go next?

being proficient at coding is just the beginning

- more at a local level

the next level is system design

- channel code properly
- understand relevant stakeholders and existing comoponents
  hello, my name id chttid
  hello, my name is chrischruachrischruschrischruschriiischrisvhc
