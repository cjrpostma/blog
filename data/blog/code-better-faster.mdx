---
title: Notes from a lecture on coding better, faster
date: '2022-11-20'
tags: ['career']
draft: true
summary: TODO
---

2035 baylor ave 80027 9-2

2 axes of good code machine

- quality
- velocity

code machine is a recognized term for staff engineer type. archetypes at meta
product manager archteype
code machine archetype

you dont have to sacrifice quality for velocity

high quality code is conducive to high output
important at any level

even highest level engineers still spoend 20% of their time writing code

---

code quality is by far the most misunderstood metric

- trademark sign of a bad software engineer is low quality

you can always throw more hours to increase quanitty, cannot do so for quality

apply 80/20 rule for quality

how to think about/optimize velocity

how to think about/optimize quality

VELOCITY

Go deep, not wide

- pick one tech stack and stick with it
- breaadth is cheap
- takes 2-4 years to become proficient at a stack
- avoid being full stack
- will eventually hit an inflection point wher eyou can code really fast
- dont switch stacks to maximize job opportunity

Be tactical with meetings

-common failure mode is to attend every meeting on your calendar

- juniors commonly do this
- skip meetings where you arent a major player
- always retrospect on meeting value
- establish focus blocks
  --long period of time that is uninterrupted where you can focus
  -- should be for coding
  -- coding is heavily momementum oriented
  --- context switching is really disruptive, takes a long time to get the context to code
  --- takes time to set up environment, context

an engineer with 1 x 8 hours will produce twice as much as code as an engineer with 4 x 2 hour blocks
try to have 1-2 days per week with no interruptions

Look for patterns

all tech stacks follow a power law

- some components matter far more than others

example: rendering a list of items on mobile

- should have an opinion on this
- e.g. there are three ways to do this, this way is better for this reason, etc. pros and cons

identify common components to master

once you have identified these patterns, which may be unique per team/org,
get really good at them, at those patterns

learn how to get really good at these common things/patterns

Do side projects

- "Life hack" to write more code without overworking
- Build things for fun on the side
- This builds skills
- if you want to get better at a skill, just need to spend more time practicing that skill

expecially ppowerfully if you work at a startup and work on frontend

- can almost copy/paste code from your personal side project into work work
  because youve already solved a lot of problems in your side projects

other benefits of side project

- fun
- builds more holistic product skills
- make you a more complete engineer
- will help spark creativity at work
- will help you learn more modern ways to do things because work proejcts might persist older patterns
- side projecvt allows you to explore modern approaches

Time spent after writing code

what is the breakdown of how time is spent

what happens once you write the code to getting it landed (eg committed to main)

noob engineer

- submit code for review
  -- add summary, test plan, screenshots, does some but not much here
- receive code review
- resolve comments, merge conflicts
- Land code into main

Pro engineer

- submit code for review - spends longer here, screenshots, videos, etc
  --- very ccarefully explains everything
- code review time is way faster due to step one being more complete
- land code -- takes less time, will land the code right away, this time should be as fast as possible
  want cycle to be super quick
  pro engineer explains very well what they are doing
  anticipates the questions that other people will have in the test plan summary

HOW DO I INSERT AN IMAGE HERE?

QUALITY

Create a plan

- try to visualize your approach and come up with a plan
  -- dont jumop right into coding
  --crucial with meatier tasks ( greater than 3 days)
- dont just start coding your first idea, come up with alternative ideas
- jsut spend at least 15-30 minutes to come up with a plan
- come up with pros/cons of approaches

Submit clean pull requests

- code is much mroe than the raw lines of code
-

- Make commit focused/atomic, 25-250 lines of code, otherwise robbing yourself of feed back that yiou need
  explain what PR is trying to accomplish and how
- Proactively surface potential problem areas
  ---- mention on pull request if yiou think there are issues in your PR, be proactive
  ---- can mention code smells or areas you think are messy in your own PR

- Have a great test plan
  -- Show waht the code is trying to do
  -- if on front end, 99% of the time you want to attach video or gif
  if backend, screenshot of postman, curl, etc
- providing more info not oinly shows that your code works but also builds up confidence in yiour code from rest of yoru
  team
- doing the above will also result in faster code review because it is easier to review
- test plan should communicate a narrative, waht changes the code makes
- state of world, made code change, new state of the world....explain this narrative
- prove the change and how it looks/works
- call out the significant lines of code ( the import parts of the changes)

Treat code review feedback as a massive gift

- respond quickly and with appreciation
- ideally within 1-4 hours, 24 hour turnaround max
- code review is one the primary ways you can grow
- dont make the same mistake twice, absorb the feedback, if you dont get it, ask questions
- dont be afraid to hop on a call to explain concepts in PR

Review code from others

- a couple hours per week to review code from other team members even if you cannot approve
- help your teammates
- find areas for improvement that you can make

Modularize your code

-dont put everything into one class

- every component should have a single responsibility
- namign is very important, use descriptive names to make this clear
- more modularization ===increased flexibility === increased reusability

Keep it consistent

- follow what the surrounding code is doing
- even if the existing patterns are suboptimal, just do the same thing, having two patterns, even if one is better
  really makes the code harder to read
  if you are going to bring in a new thing, you need to migrate the whole codebase
  it is better to just have one pattern, even if that one pattern is a little older
- if you are going to improve the code, do a global scale refactor
- you can keep mental notes on thigns to improve
- code following different patterns breaks the readers' focus

Do the simple thing first

- start off with the most basic and minimal frameworks
- by using the more primitive technology, you will understand the tech better
- worst possible code is using powerful framework incorrectly

Make it a little better each time

-pay attention to pain points

-can you do the same with less code

- can you make it more readable
- can you make it faster
- are there unhandled edge cases

note these things and discuss with other people

Where to go next?

being proficient at coding is just the beginning

- more at a local level

the next level is system design

- channel code properly
- understand relevant stakeholders and existing comoponents
  hello, my name id chttid
  hello, my name is chrischruachrischruschrischruschriiischrisvhc
